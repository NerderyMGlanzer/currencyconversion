Currency Conversion MVC Demo
=============================

I created this MVC application as a simple demonstration of some of techniques you'll 
find in larger applications:  dependency injection, unit testing, attribute routing,
asset minification, unobtrusive jQuery, and validation.

The Files
---------
**App_Start/AttributeRoutingConfig.cs**

This file is auto-generated by [Attribute Routing](http://attributerouting.net/) when it 
is added to your project.  Normally routes would be defined in a long single file like this:

    routes.MapRoute(
        "MyCoolPage",                                           // Route name
        "my/cool/page",                                         // URL with parameters
        new { controller = "MyController", action = "CoolAction" }  // Parameter defaults
    );
    
Instead you can more cleanly do this in the controller, which helps with maintainability:

    public class MyController : Controller
    {
        [GET("my/cool/page")]
        public ActionResult CoolAction()
        {
          // stuff
        }
    }
    
**App_Start/NinjectWebCommon.cs**

This file is auto-generated by [Ninject](http://www.ninject.org/) when it is added to your
project.  Ninject takes care of dependency injection, so your code is easier to unit test.
You will want to modify RegisterServices to associate your service interfaces with their 
main implementations, and Ninject will take care of the rest.

    private static void RegisterServices(IKernel kernel)
    {
        kernel.Bind<IMyService>().To<MyService>();
    }  
        
**CurrencyConversion/Content**

The typical location where you store style sheets and associated images.

**Controllers/CurrencyController.cs**

Controllers are the main part of your MVC application.  They take the data from a database
or a web service, modify or combine other data appropriately, create a view model, and send
it to the view.  Or the inverse, if you're working with data posted back from the user.

On the top of this controller you will notice:

    public CurrencyController(ICurrencyService currencyService)
    
If a controller is instantiated by the MVC framework, how does it get an instance of
the CurrencyService?  [Ninject](http://www.ninject.org/) takes care of this automatically,
based on the mappings you setup in *App_Start/NinjectWebCommon.cs*.  If for some reason or
another you wouldn't want to use a dependency injection framework, you could use this
altnernative, which would still easily allow for unit testing:

    private ICurrencyService _currencyService;
    protected internal ICurrencyService CurrencyService
    {
        get { return _currencyService = _currencyService ?? new CurrencyService(); }
        set { _currencyService = value; }
    }
    
Next you'll see the Index() action, which is pretty self explanitory.  We first use 
[Attribute Routing](http://attributerouting.net/) to map the root directory to this action.
Inside the function, we hit the service to get the list of available currencies.  We create
a new instance of the view model, pass in the currencies, setup some defaults, and pass
it to the view. How does it know what view to display?  By default, calling View() will look for
*/Views/[Controller]/[Action].cshtml*

The Convert() action takes in the posted back form.  Since we created the form elements
using MVC's HTML helpers in the view, MVC automatically mapped the values back to our view model.
We do some server side validation, if the user tried to thwart it on the client side,
then do the calculation and return the value back to the user.

**/Extensions/DictionaryExtensions.cs**

This file is an example of an extension method.  An extension method is similar to a category
in objective-c.  It allows you to add a method to a class that isn't your own.  In this instance, 
we're adding ToQueryString() to a dictionary of strings to create a query string for a URL. 
It is namespaced to the same namespace as the class we are adding on to for intellisense reasons,
with the downside of the posibility of having conflicts with other extension methods.

    var parameters = new Dictionary<string, string>();
    parameters.Add("app_id", "blabla");
    string queryString = parameters.ToQueryString();
    
Will generate:

    ?app_id=blabla
    
**/Models/Currency/IndexModel.cs**

This is the model we use for the index action on the currency controller.  Typically a view model
will map one-for-one with what is needed in the view.  For example, if you are formatting a date
to be displayed on the view, your view model should have a string where you will store the formatted 
date.  You want to have minimal logic in the view.  You also don't want to pass a raw database or
service model to the view.

You'll notice the validation rules are also on the model in the form of attributes.  They are both
used for jQuery Validate (generated by the html helpers in the form of HTML 5 attributes) and for 
MVC's server-side validation.
